---
description: Next.js 15 App Router + TypeScript 코딩 패턴 및 컨벤션
globs: app/**/*.{ts,tsx}
alwaysApply: false
---

# Next.js + TypeScript 코딩 패턴

## 클라이언트 컴포넌트

모든 인터랙티브 컴포넌트는 `'use client'` 지시어를 사용합니다.

```tsx
// ✅ GOOD
'use client';

import React from 'react';

export default function MyComponent() {
  return <div>...</div>;
}
```

## 파일 구조

- **페이지**: `app/(main)/featureName/page.tsx`
- **레이아웃**: `layout/ComponentName.tsx`
- **컴포넌트**: `components/feature/ComponentName.tsx`
- **훅**: `hooks/useFeatureName.tsx`
- **스토어**: `store/useFeatureStore.ts`
- **타입**: `types/featureName.ts`
- **상수**: `constants/featureName.ts`
- **유틸**: `util/utilityName.ts`

## 타입 정의

인터페이스는 파일 상단에 정의하고, 타입은 별도 `types` 디렉토리에 분리합니다.

```tsx
// ✅ GOOD
interface User {
  id: number;
  name: string;
  email: string;
}

// ❌ BAD - any 사용
const user: any = { ... };
```

## React Hooks 패턴

### useState
```tsx
const [state, setState] = useState<Type>(initialValue);
```

### useEffect
```tsx
useEffect(() => {
  // 사이드 이펙트
  return () => {
    // cleanup
  };
}, [dependencies]);
```

### useCallback
```tsx
const handleClick = useCallback((id: number) => {
  // 핸들러 로직
}, [dependencies]);
```

### useMemo
```tsx
const filteredData = useMemo(() => {
  return data.filter(item => item.active);
}, [data]);
```

## 에러 처리

try-catch 블록에서 항상 에러를 적절히 처리합니다.

```tsx
// ✅ GOOD
try {
  const response = await http.get('/api/data');
  // 처리
} catch (error: any) {
  console.error('Error:', error);
  showToast({
    severity: 'error',
    summary: '에러',
    detail: error.response?.data?.message || '처리 중 오류가 발생했습니다.'
  });
}
```

## 조건부 렌더링

```tsx
// ✅ GOOD
{isLoading && <LoadingSpinner />}
{data && <DataDisplay data={data} />}
{error && <ErrorMessage error={error} />}
```

## Next.js 라우팅

- App Router 사용 (`app/` 디렉토리)
- 라우트 그룹: `(main)`, `(full-page)`
- 동적 라우트: `[id]` 폴더명 사용
